# algo_study_greedy

알고리즘 공부(greedy)

- 동빈나
- 백준

## greedy

### 구현

- 풀이는 떠 올리는 것 이지 소스코드 옮기기 하드
- 알고리즘 문제에서는 2차원 공간은 행렬로 처리
- ex 5행 5열  
   `for i in range(5): 
for j in range(5):
      print('(', j,',',')' ,end='') `
- 위치 확인 시에 동서남북이동 리스트로 만들어 놓기  
  dx=[0,-1,0,1]  
  dy=[1,0,-1,0]  
   동,서,남,북

# 행과 열이 숫자와 문자열 결합된 문제

- 숫자는 int로 변형하고 문자일 경우 **ord(문자)** 를 사용하여 아스키코드로 변경후 **ord('a')를 빼고 +1** 히여 좌표를 맞추어 준 후 시작

# 알파벳 정렬 문제

- 알파펫을 오름 차순으로 정렬하고 뒤에는 숫자를 더해 출력한다
- 문자열을 입력하였을 때 문자를 하나씩 확인
- 숫자인 경우 따로 합계
- 문자인 경우 따로 리스트에 저장(**isalpha**사용!!!)

---

## DFS/BFS

- 그래프 탐색 알고리즘
- 탐색⇒ 많은 양의 데이터중 **원하는 데이터를 찾는 과정**
- 스택 자료구조
  먼저 들어온 데이터가 나중에 나가는 형식(선입후출)의 자료구조
  입구와 출구가 동일한 형태  
  EX) 삽입(5)- 삽입(2)-삽입(3)- 삽입(7)-삭제()-삽입(1)- 삽입(4)-삭제()  
   => 5231로 된다 7과 4가 삭제 된것  
   리스트를 이용하면 된다.
  - append(),pop()사용
  - 최상단 부터 원하면 stack[::1]
- 큐 자료구조
  먼저 들어온 것이 먼저 나가는 형식(선입선출)의 자료구조  
   ⇒ 편의점 알바 할 때 음료 생각!!  
   입구와 출구가 뚫려 있는 터널과 같은 형태  
   EX) 삽입(5)- 삽입(2)-삽입(3)- 삽입(7)-삭제()-삽입(1)- 삽입(4)-삭제()  
   => 4173로 된다(나중에 들어온 순서)  
   `from collection import deque `  
   `queue=deque()`  
   사용하고 deque의 삽입 함수는 append()  
   삭제 함수는 popleft()  
   순서 바꿀때는 reverse()
- 유클리드 호제법(최대 공약수 구할때 사용 알고리즘)  
  두 자연수 A,B 에 대하여 (A>B) A를 B로 나눈 나머지를 R이라고 할 경우  
  A,B의 최대 공약수는 B와R의 최대 공약수와 같다
