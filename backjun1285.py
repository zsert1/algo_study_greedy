## 동전 뒤집기 비트 마스킹(행을 뒤집는 연산을 최소화하기 위하여) 공부 조금더 하고 재도전
# DP 문제
# << >> 비트 단위 시프트 연산자 사용하자
# << 오른쪽 0이 주어진 개수만큼 추가
# 10<<1 =>20
# 10<<2 =>40
# 10>>1 =>5
# 10>>2 =>2

# >> 왼쪽에 0이나 1아 갯수만큼 추가 

# 만약 초기배열인 arr배열을 그대로 사용하면 처음의 경우를 확인한 후, 다음의 경우를 확인하지 못하기 때문이다.
# 그래서 각 경우의 수마다 초기의 배열을 복사하여 사용한다.
# for문을 돌려 비트값의 각 자리수에 1이 있는지 확인하고 만약 1이 있으면 해당 행의 동전을 모두 뒤집어준다. 비트값의 자리수가 1이면 해당 행을 뒤집어 준다는 의미이기 때문이다.
# 해당 비트값을 이용해 행을 뒤집어 주었으면 이제 열을 확인한다.
# 17번째의 줄의 cnt는 해당 경우의 수에 T의 총 갯수를 저장할 변수이다.
# 이후 행을 확인할 for문을 돌리고 각 열에 대해 T의 갯수를 저장할 cnt_t를 생성한다.
# 열을 확인할 for문을 돌리고 각 열에 대해 T의 갯수를 cnt_t에 저장한다.
# 각 열을 모두 확인 할 때마다 cnt에 cnt_t와 (n-cnt_t)를 비교하여 작은 값을 더한다.
# 이유는 cnt_t가 작으면 해당 열은 뒤집지 않고 크면 뒤집어 T의 갯수를 최소화 하기 위해서 이다.
# 해당 비트값에 대해 행과 열을 모두 확인하면 ans에 해당 경우의수에 대해 총 T의 갯수 cnt와 ans값을 비교하여 최소값을 저장한다.
# 모든 경우의 수를 돌리는 로직
n=int(input())
arr=[]
for _ in range(n):
    arr.append(list(input()))
 # 최대 경우의수 
ans=n*n
 
for bit in range(1<<n):
    # 새로운 동전 배열인 tmp를 만들어 슬라이싱을 이용해 초기의 배열을 복사해준다.
    tmp=[arr[i][:] for i in range(n)]
    for i in range(n):
    # bit의 i번째 비트가 켜져 있는지 확인하는 연산
        if bit & (1<<i):
            for j in range(n):
                if tmp[i][j]=='T':
                    tmp[i][j]='H'
                else:
                    tmp[i][j]='T'
    cnt=0
    for i in range(n):
        cnt_t=0
        for j in range(n):
            if tmp[j][i]=='T':
                cnt_t+=1
        cnt+=min(cnt_t,n-cnt_t)
    ans=min(cnt,ans)
 
print(ans)

# 비트 마스킹으로 가능한 모든 경우의 수 생성: 주어진 n개의 요소에 대해 가능한 모든 부분 집합(즉, 각 요소가 선택되거나 선택되지 않는 모든 경우)을 생성합니다. 이것은 for bit in range(1<<n)와 같은 반복문으로 수행됩니다.
# 각 경우에 대해 원하는 연산 수행: 각 비트마스크에 대해 원하는 연산을 수행합니다. 예를 들어, if bit & (1<<i)와 같은 코드로 i번째 요소가 선택된 경우 해당 조건문 내부에서 원하는 연산(예: 행 뒤집기)을 수행하게 됩니다.
# 최적화 기법 적용: 만약 문제가 최적화 문제라면 (예: 최소값 찾기, 최대값 찾기 등), 그 결과를 저장하고 갱신하는 로직이 필요합니다. 이는 종종 동적 프로그래밍(DP)과 함께 사용됩니다.
# 결과 출력: 마지막으로, 계산된 결과를 출력합니다.